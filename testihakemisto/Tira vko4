Vko4 TIRA

T1
Eli meillä on kaksi taulua, toisessa mutterit, toisessa pultit.

Merkataan pultteja, ja niitä vastaavia muttereita kokonaisluvuilla 1,2,3...n.

Puttien ja mutterien taulut ovat satunnaisessa järjestyksessä, joten suora lomittaminen ei onnistu.

Lähdetään liikkeelle pulttitaulukon läpikäymisestä, jonka aikana jokaiselle pultille etsitään vastaava mutteri. Koska jokainen pultti on käytävä läpi kerrallaan ja jokaista verrattava johonkin mutteriin, on tämän listan läpikäyminen hoidettava loopilla, jonka aikavaatimuus on taulukon pituus * rivien määrä, eli O(n). Täten vertailukohdan aikavaatimus on oltava O(log n), jotta päästäisiin kokonaisaikavaatimukseen 0(nlog n).

Javan HashSet tarjoaa nopean kyselyn siitä, onko alkio taulukossa, joten käytämme mutterien tauluun sitä. Täten jokaisen pultin kohdalla puolitetaan taulu ja selvitetään, kummalla puolella haluttu mutteri on. Täten oikean puolen löydyttyä, toistetaan puolitus ja kysely, kunnes ollaan löydetty yksialkioinen taulu, joka sisältää halutun mutterin, joten parin indeksi on löytynyt, ja jatkamme seuraavaan. 

Taulun läpikäyminen puolittamalla vie ajan O(log n), joten kokonaisaikavaatimuksesksi saadaan haluttu O(nlog n).

T2

ArrayDequen kapasitetti on rajaton; kasvaa tarvittaessa. Ei nulleja. Toimii nopeammin kuin LinkedList käytettäessä jonona. Lisäykset toimii aikavaatimuksiltaan pääosin O(1),paitsi silloin, kun kokoa on kasvatettava, jolloin nopeus on O(n), mikä on vain ajoittainen tapahtuma. Muut operaatiot tomivat lineaarisesti. Osaset eivät muokattavana  iteroinnin aikana.

Linkedlist on kahteen suuntaan linkitetty lista, joten jokaisesta alkiosta löytyy viite seuraavaan sekä edelliseen alkioon. Lisääminen, poistaminen ja muokkaaminen on nopeaa vain, jos käsitellään ensimmäistä tai viimeistä elemnttiä, mulloin operaatiot toimivat tehokkuudella O(n). LinkedListin toiminta hitaampaa kuin ArrayDequen, sillä jokaisen lisättävän elementin kohdalla itse alkion lisäksi on lisättävä viitteet seuraavaan ja edelliseen.

Isoilla syötteillö ArrayDeque huomattavasti nopeampi kuin LinkedList. (10 000 000 alkiota ArrayDeque 3s LinkedList 9s).


T3

LinkedList on kahteen suuntaan linkitetty lista. ArrayList kuin pino, jonka välistä poistettaessa joudutaan rakentamaan koko pino uusiksi; ensimmäiseen jäseneen ei ole suoraa pääsyä. Koska LinkedListissä null on sallittu arvo, ei ole kummallista, että ensimmäisien arvojen poistaminen on siinä kevyempi operaatio kuin ArrayListissä -> ArrayListissä joudutaan kopioimaan aina koko taulukko uusiksi tällöin, koska ensimmäinen arvo ei voi olla tyhjä arvo, vaan kaikkia arvoja pitäisi täten siirtää yksi indeksi taaksepäin.

Kokeiltu 10 000 000 alkion kokoinen taulukko, josta poistettu 1000 ensimmäistä alkiota. ArrayListillä toimintoon aikaa kului yli minuutti, kun taas LinkedList käytti tähän vain 9 sekuntia.

Johtopäätös: LinkedList tökkii kaikkialla, paitsi tilanteessa, jossa ensimmäisestä alkiosta on usein päästävä eroon. 

T5 T6

Kaikki operaatiot muuten toimii vakioajassa, paitsi alkion pyytäminen, jossaa joudutaan kopioimaan koko lista ensin "ylösalaisin", jotta pinosta saataisiin alin alkio, ja jonosta viimeinen, minkä jälkeen lista kopioidaan uudelleen alkuperäiseen muotoonsa, joten kokonaiskesto on rivit + 2 * (taulukon koko * loopinrivit) eli aikavaatimus on O(n).

